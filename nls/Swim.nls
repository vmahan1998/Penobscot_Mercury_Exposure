to swim
  ;; ==========================================================
  ;; Fish movement control integrating swimming energy metabolism
  ;; ==========================================================
   set previous-patch patch-here
  ;; ------------------------------------------
  ;; LANDWARD MIGRATION (pre-spawning)
  ;; ------------------------------------------
  if not fleeing? [
  if landward-migration? [
    calculate-cost-to-home home-patch
    calculate-difficulty-landward
    calculate-swimming-speed-landward

    ;; Move upstream if energetic enough
    if not foraging? [
      selective-tidal-stream-transport-landward
    ]

  ]

  ;; ------------------------------------------
  ;; SEAWARD MIGRATION (post-spawning) OR CRITICAL ENERGY LOW
  ;; ------------------------------------------
  if seaward-migration?[
    calculate-cost-to-sea migration-patch
    calculate-difficulty-seaward
    calculate-swimming-speed-seaward

    ;; Migrate only if energetic enough
    if not foraging? [
      selective-tidal-stream-transport-seaward ;; swim energy cost is in here
    ]

  ]
]

  if fleeing? [
  flee-stripedbass
  decide-chase-direction
  let travel-distance (speed / 3)
  let cur-loc [patch-here] of myself  
  ;; get the patch directly in front at that distance
  let patch-options patches in-radius travel-distance with [
  patch-terrain = "water" and
  abs (subtract-headings (towards myself) [heading] of myself) < 90
]

  ;; pick the closest one in front
  let target-patch min-one-of patch-options [ distance myself ]
  calculate-cost-to-prey target-patch
  let path build-path-to-prey cur-loc target-patch
  set planned-path path
  
  ;; 4. Determine how many patches to move this tick
  let steps-to-move ceiling travel-distance
  let move-patches sublist planned-path 0 (min list steps-to-move length planned-path)
  
  ;; Store where the bass started this tick
  let old-patch patch-here
  
  ;; 5. Move along the planned patches IN ORDER
  foreach move-patches [ p ->
    
    ;; Count patch **visits**
    if p != old-patch [
      ask p [
        set visits-by-alewife visits-by-alewife + 1
      ]
      set old-patch p
    ]
    
    ;; Move to the patch
    face p
    move-to p
    
    ;; Count **time spent**
    ask p [
      set ticks-spent-alewife ticks-spent-alewife + 1
    ]
  ]

  ;; IMPORTANT:
  ;; Store the final patch we actually ended up on
    let next-step last move-patches
  
  ;; 6. Compute difficulty of this patch (landward vs seaward)
  calculate-chase-difficulty next-step

]
  ;; ------------------------------------------
  ;; UNIVERSAL METABOLIC COST (swimming energy)
  ;; ------------------------------------------
  calculate-swim-energy

end

to calculate-swim-energy
  let beta 0.75 
    
  ;; --- Modify energy multiplier by hydrodynamic difficulty and efficiency ---
  ;; Higher difficulty → higher cost
  ;; Lower swim-efficiency → higher cost
  let energy-multiplier (difficulty-factor * (1 / swim-efficiency))

  ;; --- Compute effective swimming energy expenditure ---
  set E-swim swim-base * (energy-multiplier ^ beta)  ;; exponential scaling for realism

  ;; --- Deduct swimming cost from total energy ---
  set energy max list 0 (energy - E-swim)  ;; ensures energy doesn’t drop below 0

  ;; --- Optional debugging output ---
  ;show (word "Swim Energy Cost: " precision swim-Ex 4
  ;      " | Swim-efficiency: " precision swim-efficiency 3
  ;      " | Difficulty: " precision difficulty-factor 3
  ;      " | Base Cost: " precision swim-base 4
  ;      " | Energy: " precision energy 2)
end

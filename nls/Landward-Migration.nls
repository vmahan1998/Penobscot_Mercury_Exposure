to calculate-difficulty-landward
  ;; Ensure required parameters exist
  ;; Ensure required parameters exist
  let M-max max [size] of breed         ;; Maximum size among agents
  let M-agent size                      ;; Current agent size
  let V-max max-seaward-velocity        ;; Maximum observed seaward velocity
  let V-min max-landward-velocity        ;; Minimum observed seaward velocity
  let k 0.75                            ;; Scaling exponent (same as landward)

  ;; Normalize velocity within its observed range (V-min to V-max)
  let normalized-velocity (velocity - V-min) / (V-max - V-min)

  ;; Theoretical raw difficulty (same base equation as landward)
  let Df-raw (normalized-velocity / (M-agent / M-max)) ^ k
  
  ;; Normalize difficulty to scale 1–10 based on normalized velocity
  ;; Difficulty = 1 at V-min (normalized-velocity = 0), 10 at V-max (normalized-velocity = 1)
  set difficulty-factor (1 + 9 * Df-raw)

  ;; Ensure difficulty is always within [1,10] range
  set difficulty-factor max list 1 (min list 10 difficulty-factor)

  ;; Debugging output
  ;show (word "Landward Difficulty Factor: " difficulty-factor 
  ;      " | Velocity: " velocity)
end

to calculate-swimming-speed-landward
  ;; Scaling factors
  let k -0.75  ;; Controls how velocity influences swimming ability
  let energy-factor (energy / 100)  ;; Energy-dependent swimming ability (0-1)
  
  ;; Compute desired speed (without capping)
  let velocity-impact (k * velocity * 300)  ;; Velocity directly influences speed but scale to 5 minutes
  let desired-speed (max-speed * energy-factor / difficulty-factor) + velocity-impact

  ;; Ensure speed is within valid bounds
  set desired-speed min list max-speed (max list min-speed desired-speed)

  ;; Cap rate of change (max acceleration per tick)
  let max-speed-change 0.5  ;; Maximum allowed change per tick

  ;; Apply capped rate of change
  if abs(desired-speed - prev-speed) > max-speed-change [
    if desired-speed > prev-speed [
      set speed prev-speed + max-speed-change  ;; Gradual increase
    ]
    if desired-speed < prev-speed [
      set speed prev-speed - max-speed-change  ;; Gradual decrease
    ]
  ] 
  if abs(desired-speed - prev-speed) <= max-speed-change [
    set speed desired-speed  ;; If within limits, set normally
  ]

  ;; Store previous speed for next tick
  set prev-speed speed

  ;; Debugging output
  ;show (word "Swimming Speed (m/5 min): " speed " | Energy Factor: " energy-factor " | Velocity Impact: " velocity-impact)
end

to migrate-landward
  ;; STEP 1: Schooling logic
  find-schoolmates
  
  if any? schoolmates [
    find-nearest-neighbor

    ifelse distance nearest-neighbor < minimum-separation [
      separate
    ][
      cohere
      align
    ]

    adjust-speed
  ]
  ;; STEP 2 move along path
  let travel-distance (speed / 3)
  let path build-path patch-here home-patch
  set planned-path path
  ;; if a valid path exists
  if not empty? path [
    ;; number of steps to move — e.g., how many patches to advance this tick
    let steps-to-move ceiling travel-distance
    
    ;; slice the path to move only that far (avoid exceeding path length)
    let move-patches sublist path 0 (min list steps-to-move length path)
    
    ;; move turtle along the path without jumping entire distance at oenc
    
    foreach move-patches [ p ->
      face p
      move-to p
    ]
  ]
  ;; STEP 3 set trail and calculate energy loss
  set energy max list 0 (energy - swim-base)  ;; Reduce energy cost of swimming
  
  if not member? patch-here trail [
  set trail lput patch-here trail
]
  
end

to calculate-cost-to-home [homing-patch]
  ask home-patch [
    set cost-to-home 0
  ]
  ask patch-here [ set cost-to-home 1e9 ]
  ;; Start with a list containing the home patch
  let frontier (list home-patch)
  let df difficulty-factor           ;; capture it locally

  while [not empty? frontier] [
    let current first frontier
    set frontier but-first frontier

    ask current [
      let current-cost cost-to-home
      
      ask neighbors4 with [patch-terrain = "water"] [
        let travel-cost compute-travel-cost current self df
        let new-cost current-cost + travel-cost

        if new-cost < cost-to-home [
          set cost-to-home new-cost
          set frontier lput self frontier
        ]
      ]
    ]
  ]
end


to-report build-path [current-patch homing-patch]
  ;; Must call `calculate-cost-to-home home-patch` before using this.
  ;; Returns a list of patches representing the least-cost route from current-patch to home-patch.

  let path (list current-patch)   ;; start list with current patch
  let cur current-patch
  let max-steps 2000              ;; safety stop to avoid infinite loops

  while [cur != home-patch and max-steps > 0] [
    set max-steps max-steps - 1

    ;; only consider water neighbors with lower cost-to-home
    let candidates [neighbors4] of cur
    set candidates candidates with [
      patch-terrain = "water" and cost-to-home < [cost-to-home] of cur
    ]

    if not any? candidates [
      ;; dead end – stop building path
      report path
    ]

    ;; choose the next patch with the minimum cost-to-home
    let next-patch min-one-of candidates [cost-to-home]

    ;; add next patch to path
    set path lput next-patch path

    ;; move the "cursor" forward
    set cur next-patch
  ]

  report path
end

to-report reconstruct-path [came-from current]
  let total-path (list current)
  while [table:has-key? came-from current] [
    set current table:get came-from current
    set total-path fput current total-path
  ]
  report total-path
end


to-report compute-travel-cost [from-patch to-patch df]
  ;; Compute travel cost for moving from from-patch to to-patch,
  ;; scaled by difficulty factor df (passed in by the calling turtle).
  ;; Keeps your original base calculation:
  ;;   base-cost = abs(velocity at to-patch) + 0.5 * max(0, depth_to - depth_from)
  ;; and returns base-cost * df (df defaults to 1 if non-numeric).
  let raw-vel [velocity] of to-patch
  let velocity-resistance ifelse-value is-number? raw-vel [ abs raw-vel ] [ 0 ]

  let from-level [depth] of from-patch
  let to-level [depth] of to-patch
  let slope 0
  if (is-number? from-level and is-number? to-level) [
    set slope max list 0 (to-level - from-level)
  ]

  let base-cost velocity-resistance + 0.5 * slope

  ;; ensure df numeric (fall back to 1)
  let df2 ifelse-value is-number? df [ df ] [ 1 ]

  ;; final non-negative cost
  report max list 0 (base-cost * df2)
end
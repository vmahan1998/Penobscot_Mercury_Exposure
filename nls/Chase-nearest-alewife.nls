to chase-nearest-alewife ;; predator procedure
    let travel-distance (speed / 3)
    let nearest-alewife-prey min-one-of prey-in-vision [distance myself]
    if nearest-alewife-prey != nobody [
      face nearest-alewife-prey
      let d distance nearest-alewife-prey
      let step min list travel-distance d  ;; clamp
      fd step
    ]
  decide-chase-direction ; dynamic swimming difficulty
  calculate-swim-energy ; based on travel direction
end

to chase-nearest-alewife_old  ;; predator procedure
  ;; 1. Find prey and decide direction
  find-target-prey
  decide-chase-direction
  
  ;; 2. Calculate travel distance in patch units
  let travel-distance (speed / 3)

  ;; Default to no path
  set planned-path []
  
  if target-prey != nobody and patch-here = [patch-here] of target-prey [
  stop ;; no futher action needed
]
  ;; 3. Build a path only if prey exists
  if target-prey != nobody [
    
    let prey-loc [patch-here] of target-prey
    let cur-loc patch-here
    
    ;; Build cost map toward prey
    calculate-cost-to-prey prey-loc
    
    ;; Raw path from current patch to prey patch
    let raw-path build-path-to-prey cur-loc prey-loc

    ;; If path is non empty, drop the starting patch if it is the same as current location
    if not empty? raw-path [
      let first-step first raw-path
      let clean-path raw-path
      
      ;; If first element is current patch, skip it
      if first-step = patch-here [
        set clean-path but-first raw-path
      ]
      
      set planned-path clean-path
    ]
  ]

  ;; If there is no usable path, bail out for this tick
  if empty? planned-path [
    ;; You can still call difficulty and swim energy with current patch if you want
    ;; or just stop chasing this tick
    stop
  ]

  ;; 4. Determine how many patches to move this tick
  let steps-to-move ceiling travel-distance
  let move-patches sublist planned-path 0 (min list steps-to-move length planned-path)

  ;; Extra guard in case sublist yields empty list
  if empty? move-patches [
    stop
  ]

  ;; Store where the bass started this tick
  let old-patch patch-here
  
  ;; 5. Move along the planned patches in order
  foreach move-patches [ p ->
    
    ;; Safeguard: never face the same patch we are already on
    if p != patch-here [
      
      ;; Count patch visits
      if p != old-patch [
        ask p [
          set visits-by-stripedbass visits-by-stripedbass + 1
        ]
        set old-patch p
      ]
      
      ;; Move to the patch
      face p
      move-to p
      
      ;; Count time spent
      ask p [
        set ticks-spent-stripedbass ticks-spent-stripedbass + 1
      ]
    ]
  ]

  ;; 6. If we moved, compute difficulty of the final patch
  let next-step last move-patches
  ;calculate-chase-difficulty next-step
  
  ;; 7. Deduct hydrodynamic swimming energy
  calculate-swim-energy
  
  if not member? patch-here trail [
  set trail lput patch-here trail
]
end

;to chase-nearest-alewife ;; predator procedure
;    let alewife-prey prey-in-vision with [breed = alewives and (patchtype != "sea")] ; only chase alewives in outside of sea
;  if any? alewife-prey [
;    let nearest-alewife-prey min-one-of alewife-prey [distance myself]
;    if nearest-alewife-prey != nobody [
;      face nearest-alewife-prey
;    ]
;    
;    let travel-distance (speed / 3)
;;; 4. Determine how many patches to move this tick
;   fd travel-distance
;  ]
;end

to decide-chase-direction
  if [velocity] of patch-here > 0 [
    set chase-direction "seaward"
    calculate-difficulty-seaward   ;; uses vel inside logic
    calculate-swimming-speed-seaward
  ]
  if [velocity] of patch-here <= 0 [
    set chase-direction "landward"
    calculate-difficulty-landward
    calculate-swimming-speed-landward
  ]
end

to find-target-prey

  let candidates alewives with [
    [patchtype] of patch-here != "sea"
  ]

  ifelse any? candidates [
    ;; Filter for only edible prey (based on gape size)
    let edible-prey candidates with [
      body-depth <= [gape-size] of myself
    ]
    set target-prey min-one-of candidates [distance myself]
  ] [
    set target-prey nobody
  ]
end

to calculate-chase-difficulty [next-patch]

  let vel [velocity] of next-patch

  if chase-direction = "landward" [
    calculate-difficulty-landward   ;; uses vel inside logic
    calculate-swimming-speed-landward
  ]

  if chase-direction = "seaward" [
    calculate-difficulty-seaward
    calculate-swimming-speed-seaward
  ]
end

to calculate-cost-to-prey [prey-patch]

  ;; set initial conditions
  ask patch-here [ set cost-to-prey 1e9 ]
  ask prey-patch [ set cost-to-prey 0 ]

  ;; Start with a list containing the home patch
  let frontier (list prey-patch)
  let df difficulty-factor           ;; capture it locally

  while [not empty? frontier] [
    let current first frontier
    set frontier but-first frontier

    ask current [
      let current-cost cost-to-prey
      
      ask neighbors4 with [patch-terrain = "water"] [
        let travel-cost compute-travel-cost current self df
        let new-cost current-cost + travel-cost

        if new-cost < cost-to-prey [
          set cost-to-prey new-cost
          set frontier lput self frontier
        ]
      ]
    ]
  ]
  
end

to-report build-path-to-prey [start-patch prey-patch]
  let path (list start-patch)
  let cur start-patch
  let max-steps 500

  while [cur != prey-patch and max-steps > 0] [
    set max-steps max-steps - 1

    let candidates neighbors4 with [
      patch-terrain = "water" and
      cost-to-prey < [cost-to-prey] of cur
    ]

    if not any? candidates [ report path ]

    let next-p min-one-of candidates [cost-to-prey]
    set path lput next-p path
    set cur next-p
  ]

  report path
end
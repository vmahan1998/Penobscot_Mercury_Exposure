to selective-tidal-stream-transport-landward
  let V-patch [velocity] of patch-here
  ;; Apply swimming efficiency from metabolism
  let S-swim (speed) / 300  ;; m/s effective swim capacity

  ;; Case 1: Continue drifting if still in STST (cooldown)
  if selective-tidal-transport? and (ticks - STST-start-tick < 1) [
    let drift-distance abs V-patch * (1 - swim-efficiency)
    let drift-target one-of neighbors with [patch-terrain = "water"]
    if drift-target != nobody [
      safe-move drift-target drift-distance
    ]
    set tidal-transport-in-patch tidal-transport-in-patch + 1
    stop
  ]

  ;; Case 2: Enter STST when unable to overcome current
  if abs V-patch > S-swim and S-swim <= min-speed [
    set selective-tidal-transport? true
    set STST-start-tick ticks
    let drift-distance abs V-patch * (1 - swim-efficiency)
    let drift-target one-of neighbors with [patch-terrain = "water"]
    if drift-target != nobody [
      safe-move drift-target drift-distance
    ]
    set tidal-transport-in-patch tidal-transport-in-patch + 1
    stop
  ]

  ;; Case 3: Normal swimming resumes once able
  if S-swim > min-speed or (ticks - STST-start-tick >= 1) [
    set selective-tidal-transport? false
    calculate-swim-energy
    ;; Optional: swimming cost scales inversely with efficiency
    set energy max list 0 (energy - E-swim)
    migrate-landward
  ]
end


to selective-tidal-stream-transport-seaward
  let V-patch [velocity] of patch-here
  let S-swim (speed / 300 ) ;; m/s adjusted by metabolic condition

  ;; Case 1: Enter STST (current dominates)
  if selective-tidal-transport? and (ticks - STST-start-tick < 1) [
    let drift-distance abs V-patch * (1 - swim-efficiency)
    let drift-target one-of neighbors with [patch-terrain = "water"]
    if drift-target != nobody [
      safe-move drift-target drift-distance
    ]
    set tidal-transport-in-patch tidal-transport-in-patch + 1
    stop
  ]
  
if abs V-patch > S-swim and S-swim <= min-speed [
    set selective-tidal-transport? true
    set STST-start-tick ticks
    let drift-distance abs V-patch * (1 - swim-efficiency)
    let drift-target one-of neighbors with [patch-terrain = "water"]
    if drift-target != nobody [
      safe-move drift-target drift-distance
    ]
    set tidal-transport-in-patch tidal-transport-in-patch + 1
    stop
  ]

  ;; Case 3: Normal swimming resumes once able
  if S-swim > min-speed or (ticks - STST-start-tick >= 1) [
    set selective-tidal-transport? false
    calculate-swim-energy
    ;; Optional: swimming cost scales inversely with efficiency
    set energy max list 0 (energy - E-swim)
    migrate-seaward
  ]
end

to safe-move [target-patch move-speed]
  ;; Moves toward target only if water ahead; finds alternate if blocked
  face target-patch

  let next-patch patch-ahead move-speed
  ifelse [patch-terrain] of next-patch = "water" [
    fd move-speed
  ] [
    ;; fallback: find nearest water patch and move partially
    let nearby-water one-of patches in-radius 1 with [patch-terrain = "water"]
    if nearby-water != nobody [
      move-to nearby-water
    ]
  ]
end